#include <CLI11.hpp>
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <sstream>
#include <algorithm>
#include <nlohmann/json.hpp>
#include <TROOT.h>
#include <TInterpreter.h>
#include <TGlobal.h>
#include <dlfcn.h>
#include "NNumcalManager.h"
#include "NLogger.h"
#include "ndmspc.h"

std::string app_description()
{
  size_t size = 64;
  auto   buf  = std::make_unique<char[]>(size);
  size = std::snprintf(buf.get(), size, "%s v%s-%s", NDMSPC_NAME, NDMSPC_VERSION, NDMSPC_VERSION_RELEASE);
  return std::string(buf.get(), size);
}

// Generate header-only file with imported functions and labels
std::string generateHeaderFile(const std::vector<std::string>& expressions,
                              int ndim,
                              const std::string& inputFile,
                              const std::string& outputFile) {
  std::stringstream ss;

  // Create header guard from outputFile
  std::string guardName = "Ndmspc_" + outputFile;
  for (char& c : guardName) {
    if (!isalnum(c)) c = '_';
  }
  guardName += "_H";

  // Header guard and includes
  ss << "#ifndef " << guardName << "\n";
  ss << "#define " << guardName << "\n\n";
  ss << "#include <vector>\n";
  ss << "#include <cmath>\n";
  ss << "#include <functional>\n";
  ss << "#include <string>\n";
  ss << "#include <sstream>\n";
  ss << "#include <algorithm>\n";
  ss << "#include <iostream>\n";
  ss << "#include \"NNumcalManager.h\"\n";
  ss << "#include \"VegasIntegrator.h\"\n";
  ss << "#include \"SuaveIntegrator.h\"\n";
  ss << "#include \"DivonneIntegrator.h\"\n";
  ss << "#include \"CuhreIntegrator.h\"\n";
  ss << "#include \"NumcalResult.h\"\n\n";
  ss << "// Auto-generated header file from: " << inputFile << "\n";
  ss << "// Generated by ndmspc-numcal\n\n";
  ss << "namespace Ndmspc {\n\n";

  // Function declarations and definitions
  for (size_t i = 0; i < expressions.size(); ++i) {
    ss << "double func" << (i+1) << "(const std::vector<double>& x) {\n";
    ss << "    return " << expressions[i] << ";\n";
    ss << "}\n\n";
  }


  // get_functions function
  ss << "inline std::vector<std::function<double(const std::vector<double>&)>> get_functions() {\n";
  ss << "    return {\n";
  for (size_t i = 0; i < expressions.size(); ++i) {
    ss << "        func" << (i+1);
    if (i < expressions.size() - 1) ss << ",";
    ss << "\n";
  }
  ss << "    };\n";
  ss << "}\n\n";

  // get_labels function
  ss << "inline std::vector<std::string> get_labels() {\n";
  ss << "    return {\n";
  for (size_t i = 0; i < expressions.size(); ++i) {
    std::string label = expressions[i];
    size_t pos = 0;
    while ((pos = label.find('"', pos)) != std::string::npos) {
      label.insert(pos, 1, '\\');
      pos += 2;
    }
    pos = 0;
    while ((pos = label.find('\\', pos)) != std::string::npos) {
      label.insert(pos, 1, '\\');
      pos += 2;
    }
    ss << "        \"" << label << "\"";
    if (i < expressions.size() - 1) ss << ",";
    ss << "\n";
  }
  ss << "    };\n";
  ss << "}\n\n";

  // get_ndim function
  ss << "inline int get_ndim() { return " << ndim << "; }\n\n";

  ss << "} // namespace Ndmspc\n\n";

  ss << "#endif // " << guardName << "\n";

  return ss.str();
}

int main(int argc, char ** argv)
{

  CLI::App app{app_description()};
  app.require_subcommand(0); // 0 or more - allow running without subcommands to show help
  argv = app.ensure_utf8(argv);
  app.set_help_all_flag("--help-all", "Expand all help");

  std::string inputFile;
  std::string outputFile;
  bool verbose = false;
    int dims = 1;

    CLI::App * import = app.add_subcommand("import", "Import functions from file and generate header");
    import->add_option("-f,--file", inputFile, "Input file containing function definitions")
      ->required()
      ->check(CLI::ExistingFile);
        import->add_option("-d,--dims", dims, "Number of dimensions")
          ->required();
    import->add_option("-o,--output", outputFile, "Output header file name (default: ImportedFunctions.h)");
    import->add_flag("-v,--verbose", verbose, "Verbose output");

  // Run subcommand
  std::string runInputFile;
  std::string methods = "vegas";

  int maxeval = 10000;
  double epsrel = 1e-3;
  double epsabs = 1e-12;
  bool runVerbose = false;

  CLI::App * run = app.add_subcommand("run", "Run integration on functions from a generated header file. Use 'import' first to generate the header file. JSON configuration files allow custom parameters per method (ndim, maxeval, epsrel, epsabs, etc.)");
  run->add_option("-f,--file", runInputFile, "Header file generated by 'import' command containing compiled functions.")
      ->required()
      ->check(CLI::ExistingFile);
  run->add_option("-m,--methods", methods, "Integration methods (comma-separated: vegas,suave,divonne,cuhre). Use 'method:config.json' to specify per-method JSON configuration files. Examples: 'vegas', 'vegas,suave', 'vegas:vegas_config.json,suave:suave_config.json'")
      ->default_val("vegas");

  run->add_option("--maxeval", maxeval, "Maximum number of evaluations")
      ->default_val(10000);
  run->add_option("--epsrel", epsrel, "Relative error tolerance")
      ->default_val(1e-3);
  run->add_option("--epsabs", epsabs, "Absolute error tolerance")
      ->default_val(1e-12);
  run->add_flag("-v,--verbose", runVerbose, "Verbose output");

  // If no subcommand is provided, show help
  if (argc == 1) {
    NLogDebug("%s", app.help().c_str());
    return 0;
  }

  auto import_fun = [&]() {
    try {
      if (verbose) {
        NLogDebug("Importing functions from file: %s", inputFile.c_str());
      }

      // Read the original expressions from the input file
      std::vector<std::string> expressions;
      std::ifstream inFile(inputFile);
      std::string line;
      while (std::getline(inFile, line)) {
        // Remove comments and trim whitespace
        size_t commentPos = line.find("//");
        if (commentPos != std::string::npos) {
          line = line.substr(0, commentPos);
        }
        // Trim whitespace
        line.erase(line.begin(), std::find_if(line.begin(), line.end(), [](int ch) {
          return !std::isspace(ch);
        }));
        line.erase(std::find_if(line.rbegin(), line.rend(), [](int ch) {
          return !std::isspace(ch);
        }).base(), line.end());

        if (!line.empty()) {
          // Extract expression between "f = " and ";" or ";;"
          std::string expr = line;
          // Remove "f = " prefix if present
          if (expr.substr(0, 4) == "f = ") {
            expr = expr.substr(4);
          }
          // Remove trailing semicolons
          while (!expr.empty() && (expr.back() == ';' || expr.back() == ' ')) {
            expr.pop_back();
          }

          // Convert variable names: t0 -> x[0], t1 -> x[1], etc.
          size_t pos = 0;
          while ((pos = expr.find("t", pos)) != std::string::npos) {
            if (pos + 1 < expr.length() && isdigit(expr[pos + 1])) {
              // Found t followed by digit
              size_t digitStart = pos + 1;
              size_t digitEnd = digitStart;
              while (digitEnd < expr.length() && isdigit(expr[digitEnd])) {
                digitEnd++;
              }
              std::string digitStr = expr.substr(digitStart, digitEnd - digitStart);
              int varIndex = std::stoi(digitStr);
              expr.replace(pos, digitEnd - pos, "x[" + std::to_string(varIndex) + "]");
              pos += 3; // Move past "x["
            } else {
              pos++;
            }
          }

          expressions.push_back(expr);
        }
      }

      if (expressions.empty()) {
        NLogError("Error: No functions were found in the file.");
        return 1;
      }

      if (verbose) {
        NLogDebug("Successfully found %zu functions:", expressions.size());
        for (size_t i = 0; i < expressions.size(); ++i) {
          NLogDebug("  %zu: %s", i, expressions[i].c_str());
        }
      }

      // If outputFile is not specified, use inputFile without .txt extension
      std::string outFileName = outputFile;
      if (outFileName.empty()) {
        outFileName = inputFile;
        size_t txtPos = outFileName.rfind(".txt");
        if (txtPos != std::string::npos)
          outFileName = outFileName.substr(0, txtPos);
        outFileName += ".h";
      }
      std::string headerContent = generateHeaderFile(expressions, dims, inputFile, outFileName);
      std::ofstream outFile(outFileName);
      if (!outFile.is_open()) {
        NLogError("Error: Could not create output file: %s", outFileName.c_str());
        return 1;
      }
      outFile << headerContent;
      outFile.close();

      if (verbose) {
        NLogDebug("Generated header file: %s", outFileName.c_str());
        NLogDebug("Contains %zu functions", expressions.size());
      } else {
        NLogDebug("Successfully generated %s with %zu functions", outFileName.c_str(), expressions.size());
      }

      return 0;
    } catch (const std::exception& e) {
      NLogError("Error: %s", e.what());
      return 1;
    }
  };

  import->callback(import_fun);

  auto run_fun = [&]() {
    try {
      Ndmspc::NNumcalManager manager("run-manager", "Integration Run Manager");

      if (runVerbose) {
        NLogDebug("Including header file: %s", runInputFile.c_str());
      }

      // Include the header file using ROOT's interpreter
      std::string includeCommand = "#include \"" + runInputFile + "\"";
      gROOT->ProcessLine(includeCommand.c_str());

      
      // Get functions, labels, and ndim from the interpreter
      auto functions = (std::vector<std::function<double(const std::vector<double>&)>>*)gROOT->ProcessLine("new std::vector<std::function<double(const std::vector<double>&)>>(Ndmspc::get_functions());");
      auto labels = (std::vector<std::string>*)gROOT->ProcessLine("new std::vector<std::string>(Ndmspc::get_labels());");
      dims = ((int)gROOT->ProcessLine("Ndmspc::get_ndim();"));
      manager.SetFunctions(*functions, *labels);
      delete functions;
      delete labels;
      manager.Print();


      // Parse methods string - support both "method" and "method:file.json" formats
      struct MethodConfig {
        std::string method;
        std::string configFile;
        bool hasConfig;
      };

      std::vector<MethodConfig> methodConfigs;
      std::stringstream ss(methods);
      std::string methodEntry;
      while (std::getline(ss, methodEntry, ',')) {
        // Trim whitespace
        methodEntry.erase(methodEntry.begin(), std::find_if(methodEntry.begin(), methodEntry.end(), [](int ch) {
          return !std::isspace(ch);
        }));
        methodEntry.erase(std::find_if(methodEntry.rbegin(), methodEntry.rend(), [](int ch) {
          return !std::isspace(ch);
        }).base(), methodEntry.end());

        // Parse method:config.json format
        MethodConfig config;
        size_t colonPos = methodEntry.find(':');
        if (colonPos != std::string::npos) {
          config.method = methodEntry.substr(0, colonPos);
          config.configFile = methodEntry.substr(colonPos + 1);
          config.hasConfig = true;
        } else {
          config.method = methodEntry;
          config.hasConfig = false;
        }

        // Convert to lowercase
        std::transform(config.method.begin(), config.method.end(), config.method.begin(), ::tolower);

        if (config.method == "vegas" || config.method == "suave" || config.method == "divonne" || config.method == "cuhre") {
          methodConfigs.push_back(config);
        } else {
          NLogError("Warning: Unknown method '%s', skipping.", config.method.c_str());
        }
      }

      if (methodConfigs.empty()) {
        NLogError("Error: No valid integration methods selected.");
        return 1;
      }

      if (runVerbose) {
        NLogDebug("Running integration with parameters:");
        std::string methodsStr;
        for (size_t i = 0; i < methodConfigs.size(); ++i) {
          methodsStr += methodConfigs[i].method;
          if (methodConfigs[i].hasConfig) {
            methodsStr += ":" + methodConfigs[i].configFile;
          }
          if (i < methodConfigs.size() - 1) methodsStr += ", ";
        }
        NLogDebug("  Methods: %s", methodsStr.c_str());
        if (!methodConfigs[0].hasConfig) {
          NLogDebug("  Dimensions: %d", dims);
          NLogDebug("  Max evaluations: %d", maxeval);
          NLogDebug("  Relative error: %e", epsrel);
          NLogDebug("  Absolute error: %e", epsabs);
        }
      }

      // Run integration for each method
      for (const auto& config : methodConfigs) {
        if (runVerbose) {
          std::string msg = "Running " + config.method + " integration";
          if (config.hasConfig) {
            msg += " (config: " + config.configFile + ")";
          }
          NLogDebug("%s:", msg.c_str());
        }

        Ndmspc::NumcalResult result;

        try {
          if (config.method == "vegas") {
            Ndmspc::VegasIntegrator::VegasOptions opts;
            if (config.hasConfig) {
              // Load from JSON file
              std::ifstream configFile(config.configFile);
              if (!configFile.is_open()) {
                NLogError("Error: Could not open config file: %s", config.configFile.c_str());
                continue;
              }
              nlohmann::json j;
              configFile >> j;
              opts = Ndmspc::VegasIntegrator::VegasOptions::from_json(j);
              if (runVerbose) {
                NLogDebug("  Loaded config: ndim=%d, maxeval=%d, epsrel=%e, epsabs=%e", opts.ndim, opts.maxeval, opts.epsrel, opts.epsabs);
              }
            } else {
              // Use command line defaults
              opts.ndim = dims;
              opts.maxeval = maxeval;
              opts.epsrel = epsrel;
              opts.epsabs = epsabs;
            }
            result = manager.RunVegas(opts);

          } else if (config.method == "suave") {
            Ndmspc::SuaveIntegrator::SuaveOptions opts;
            if (config.hasConfig) {
              std::ifstream configFile(config.configFile);
              if (!configFile.is_open()) {
                NLogError("Error: Could not open config file: %s", config.configFile.c_str());
                continue;
              }
              nlohmann::json j;
              configFile >> j;
              opts = Ndmspc::SuaveIntegrator::SuaveOptions::from_json(j);
              if (runVerbose) {
                NLogDebug("  Loaded config: ndim=%d, maxeval=%d, epsrel=%e, epsabs=%e", opts.ndim, opts.maxeval, opts.epsrel, opts.epsabs);
              }
            } else {
              opts.ndim = dims;
              opts.maxeval = maxeval;
              opts.epsrel = epsrel;
              opts.epsabs = epsabs;
            }
            result = manager.RunSuave(opts);

          } else if (config.method == "divonne") {
            Ndmspc::DivonneIntegrator::DivonneOptions opts;
            if (config.hasConfig) {
              std::ifstream configFile(config.configFile);
              if (!configFile.is_open()) {
                NLogError("Error: Could not open config file: %s", config.configFile.c_str());
                continue;
              }
              nlohmann::json j;
              configFile >> j;
              opts = Ndmspc::DivonneIntegrator::DivonneOptions::from_json(j);
              if (runVerbose) {
                NLogDebug("  Loaded config: ndim=%d, maxeval=%d, epsrel=%e, epsabs=%e", opts.ndim, opts.maxeval, opts.epsrel, opts.epsabs);
              }
            } else {
              opts.ndim = dims;
              opts.maxeval = maxeval;
              opts.epsrel = epsrel;
              opts.epsabs = epsabs;
            }
            result = manager.RunDivonne(opts);

          } else if (config.method == "cuhre") {
            Ndmspc::CuhreIntegrator::CuhreOptions opts;
            if (config.hasConfig) {
              std::ifstream configFile(config.configFile);
              if (!configFile.is_open()) {
                NLogError("Error: Could not open config file: %s", config.configFile.c_str());
                continue;
              }
              nlohmann::json j;
              configFile >> j;
              opts = Ndmspc::CuhreIntegrator::CuhreOptions::from_json(j);
              if (runVerbose) {
                NLogDebug("  Loaded config: ndim=%d, maxeval=%d, epsrel=%e, epsabs=%e", opts.ndim, opts.maxeval, opts.epsrel, opts.epsabs);
              }
            } else {
              opts.ndim = dims;
              opts.maxeval = maxeval;
              opts.epsrel = epsrel;
              opts.epsabs = epsabs;
            }
            result = manager.RunCuhre(opts);
          }

          // Display results
          result.SetName(config.method.c_str());
          result.Print();

        } catch (const std::exception& e) {
          NLogError("Error running %s integration: %s", config.method.c_str(), e.what());
        }
      }

      return 0;
    } catch (const std::exception& e) {
      NLogError("Error: %s", e.what());
      return 1;
    }
  };

  run->callback(run_fun);

  try {
    app.parse(argc, argv);
  } catch (const CLI::ParseError &e) {
    return app.exit(e);
  }

  return 0;
}